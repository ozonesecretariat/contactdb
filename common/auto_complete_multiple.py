"""Custom implementation for the autocomplete widget to support multiple selection
with "in" filter.

Based on admin_auto_filters/filters.py from upstream.
"""

from admin_auto_filters.filters import (
    AutocompleteFilter,
    _get_rel_model,
    generate_choice_field,
)
from django import VERSION as DJANGO_VERSION
from django.contrib.admin import SimpleListFilter
from django.contrib.admin.widgets import AutocompleteSelectMultiple as Base
from django.db.models.constants import LOOKUP_SEP
from django.urls import reverse


class AutocompleteSelectMultiple(Base):
    def __init__(
        self, rel, admin_site, attrs=None, choices=(), using=None, custom_url=None
    ):
        self.custom_url = custom_url
        super().__init__(rel, admin_site, attrs, choices, using)

    def get_url(self):
        return self.custom_url if self.custom_url else super().get_url()


class AutocompleteFilterMultiple(AutocompleteFilter):
    def __init__(self, request, params, model, model_admin):
        if self.parameter_name is None:
            self.parameter_name = self.field_name
            if self.use_pk_exact:
                self.parameter_name += "__{}".format(self.field_pk)
            self.parameter_name += "__in"
        SimpleListFilter.__init__(self, request, params, model, model_admin)

        if self.rel_model:
            model = self.rel_model

        if DJANGO_VERSION >= (3, 2):
            remote_field = model._meta.get_field(self.field_name)
        else:
            remote_field = model._meta.get_field(self.field_name).remote_field

        widget = AutocompleteSelectMultiple(
            remote_field,
            model_admin.admin_site,
            custom_url=self.get_autocomplete_url(request, model_admin),
        )
        form_field = self.get_form_field()
        field = form_field(
            queryset=self.get_queryset_for_field(model, self.field_name),
            widget=widget,
            required=False,
        )

        self._add_media(model_admin, widget)

        attrs = self.widget_attrs.copy()
        attrs["id"] = "id-%s-dal-filter" % self.parameter_name
        if self.is_placeholder_title:
            # Upper case letter P as dirty hack for bypass django2 widget force
            # placeholder value as empty string ("")
            attrs["data-Placeholder"] = self.title
        self.rendered_widget = field.widget.render(
            name=self.parameter_name,
            value=self.value(),
            attrs=attrs,
        )

    def value(self):
        val = super().value()
        if not val:
            return None
        return val.split(",")


def AutocompleteFilterMultipleFactory(  # noqa: N802
    title, base_parameter_name, viewname="", use_pk_exact=False, label_by=str
):
    """
    An autocomplete widget filter with a customizable title. Use like this:
      AutocompleteFilterFactory('My title', 'field_name')
      AutocompleteFilterFactory('My title', 'fourth__third__second__first')
    Be sure to include distinct in the model admin get_queryset() if the second form
    is used.
    
    Assumes: parameter_name == f'fourth__third__second__{field_name}'
      * title: The title for the filter.
      * base_parameter_name: The field to use for the filter.
      * viewname: The name of the custom AutocompleteJsonView URL to use, if any.
      * use_pk_exact: Whether to use '__pk__exact' in the parameter name when possible.
      * label_by: How to generate the static label for the widget - a callable, the name
        of a model callable, or the name of a model field.
    """

    class NewMetaFilter(type(AutocompleteFilterMultiple)):
        """A metaclass for an autogenerated autocomplete filter class."""

        def __new__(cls, name, bases, attrs):
            super_new = super().__new__(cls, name, bases, attrs)
            super_new.use_pk_exact = use_pk_exact
            field_names = str(base_parameter_name).split(LOOKUP_SEP)
            super_new.field_name = field_names[-1]
            return super_new

    class NewFilter(AutocompleteFilterMultiple, metaclass=NewMetaFilter):
        """An autogenerated autocomplete filter class."""

        def __init__(self, request, params, model, model_admin):
            self.rel_model = _get_rel_model(model, base_parameter_name)
            self.form_field = generate_choice_field(label_by)
            super().__init__(request, params, model, model_admin)
            self.title = title

        def get_autocomplete_url(self, request, model_admin):
            if viewname == "":
                return super().get_autocomplete_url(request, model_admin)
            return reverse(viewname)

    return NewFilter
